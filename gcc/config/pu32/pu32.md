;; SPDX-License-Identifier: GPL-2.0-only
;; (c) William Fonkou Tambe

;; -------------------------------------------------------------------------
;; Constants, constraints, predicates and attributes
;; -------------------------------------------------------------------------

(define_constants [
  (SP_REG 0)
  (RP_REG 15)])

(define_constraint "A"
 "Memory address operand"
 (ior (and (match_code "symbol_ref,label_ref")
           (match_test "SYMBOL_REF_TLS_MODEL (op) == 0"))
      (and (match_code "const")
           (match_test "GET_CODE (XEXP (op, 0)) == PLUS &&
                          (GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF ||
                            GET_CODE (XEXP (XEXP (op, 0), 0)) == LABEL_REF) &&
                          SYMBOL_REF_TLS_MODEL (XEXP (XEXP (op, 0), 0)) == 0 &&
                          CONST_INT_P (XEXP (XEXP (op, 0), 1))"))))

(define_constraint "B"
 "Memory operand"
 (and (match_code "mem")
      (ior (match_test "GET_CODE (XEXP (op, 0)) == SYMBOL_REF &&
             SYMBOL_REF_TLS_MODEL (XEXP (op, 0)) == 0")
           (match_test "GET_CODE (XEXP (op, 0)) == LABEL_REF")
           (match_test "GET_CODE (XEXP (op, 0)) == CONST"))))

(define_constraint "W"
 "Register indirect memory operand"
 (and (match_code "mem")
      (match_test "REG_P (XEXP (op, 0))")))

(define_constraint "T"
 "Memory operand"
  (ior (and (match_code "const")
            (match_test "GET_CODE (XEXP (op, 0)) == PLUS &&
                           GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF &&
                           SYMBOL_REF_TLS_MODEL (XEXP (XEXP (op, 0), 0)) != 0 &&
                           CONST_INT_P (XEXP (XEXP (op, 0), 1))"))
       (and (match_code "mem")
            (match_test "GET_CODE (XEXP (op, 0)) == SYMBOL_REF &&
                           SYMBOL_REF_TLS_MODEL (XEXP (op, 0)) != 0"))
       (and (match_code "symbol_ref")
            (match_test "SYMBOL_REF_TLS_MODEL (op) != 0"))))

(define_constraint "O"
 "Constant zero"
 (and (match_code "const_int")
      (match_test "ival == 0")))

(define_constraint "I"
  "8-bit immediate."
  (and (match_code "const_int")
       (match_test "ival >= -0x80 && ival <= 0x7f")))

(define_constraint "J"
  "16-bit immediate."
  (and (match_code "const_int")
       (match_test "ival >= -0x8000 && ival <= 0x7fff")))

(define_predicate "tls_symbolic_operand"
  (ior (and (match_code "const")
            (match_test "GET_CODE (XEXP (op, 0)) == PLUS &&
                           GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF &&
                           SYMBOL_REF_TLS_MODEL (XEXP (XEXP (op, 0), 0)) != 0 &&
                           CONST_INT_P (XEXP (XEXP (op, 0), 1))"))
       (and (match_code "mem")
            (match_test "GET_CODE (XEXP (op, 0)) == SYMBOL_REF &&
                           SYMBOL_REF_TLS_MODEL (XEXP (op, 0)) != 0"))
       (and (match_code "symbol_ref")
            (match_test "SYMBOL_REF_TLS_MODEL (op) != 0"))))

; Most instructions are two bytes long.
(define_attr "length" "" (const_int 2))

(define_attr "cost" "" (const_int 0))

;; -------------------------------------------------------------------------
;; nop instruction
;; -------------------------------------------------------------------------

(define_insn "nop"
 [(const_int 0)]
 ""
 "nop")

;; -------------------------------------------------------------------------
;; brk instruction (used by __builtin_trap)
;; -------------------------------------------------------------------------

(define_insn "trap"
 [(trap_if (const_int 1) (const_int 0))]
 ""
 "brk")

;; -------------------------------------------------------------------------
;; Arithmetic instructions
;; -------------------------------------------------------------------------

(define_insn "addsi3"
 [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
       (plus:SI
        (match_operand:SI 1 "register_operand" "0,0,0,0")
        (match_operand:SI 2 "general_operand" "I,J,n,r")))]
 ""
 {
   switch (which_alternative) {
     case 0: {
       // Logic used to prevent generating preemptctx,
       // as it must be explicitly generated using
       // the corresponding assembly and never implicitly.
       if (REGNO (operands[0]) == STACK_POINTER_REGNUM &&
           INTVAL (operands[2]) == 0)
         return "# inc8 %0, %2 # addsi3_r_0_I";
       else
         return "inc8 %0, %2 # addsi3_r_0_I";
     }
     case 1: return "inc16 %0, %2 # addsi3_r_0_J";
     case 2: return "inc32 %0, %2 # addsi3_r_0_n";
     case 3: return "add %0, %2 # addsi3_r_0_r";
     default: gcc_unreachable ();
   }
 })

(define_insn "subsi3"
 [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
       (minus:SI
        (match_operand:SI 1 "register_operand" "0,0,0,0")
        (match_operand:SI 2 "general_operand" "I,J,n,r")))]
 ""
 {
   switch (which_alternative) {
     case 0: {
       // Logic used to prevent generating preemptctx,
       // as it must be explicitly generated using
       // the corresponding assembly and never implicitly.
       if (REGNO (operands[0]) == STACK_POINTER_REGNUM &&
           INTVAL (operands[2]) == 0)
         return "# inc8 %0, -%2 # subsi3_r_0_I";
       else
         return "inc8 %0, -%2 # subsi3_r_0_I";
     }
     case 1: return "inc16 %0, -%2 # subsi3_r_0_J";
     case 2: return "inc32 %0, -%2 # subsi3_r_0_n";
     case 3: return "sub %0, %2 # subsi3_r_0_r";
     default: gcc_unreachable ();
   }
 })

(define_insn "ssmulsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
        (ss_mult:SI
         (match_operand:SI 1 "register_operand" "0")
         (match_operand:SI 2 "register_operand" "r")))]
 ""
 "mul %0, %2 # ssmulsi3"
 [(set_attr "cost" "18")])

(define_insn "mulsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
        (mult:SI
         (match_operand:SI 1 "register_operand" "0")
         (match_operand:SI 2 "register_operand" "r")))]
 ""
 "mulu %0, %2 # mulsi3"
 [(set_attr "cost" "18")])

(define_insn "smulsi3_highpart"
 [(set (match_operand:SI 0 "register_operand" "=r")
        (truncate:SI
         (lshiftrt:DI
          (mult:DI
           (sign_extend:DI (match_operand:SI 1 "register_operand" "0"))
           (sign_extend:DI (match_operand:SI 2 "register_operand" "r")))
          (const_int 32))))]
 ""
 "mulh %0, %2 # smulsi3_highpart"
 [(set_attr "cost" "18")])

(define_insn "umulsi3_highpart"
 [(set (match_operand:SI 0 "register_operand" "=r")
        (truncate:SI
         (lshiftrt:DI
          (mult:DI
           (zero_extend:DI (match_operand:SI 1 "register_operand" "0"))
           (zero_extend:DI (match_operand:SI 2 "register_operand" "r")))
          (const_int 32))))]
 ""
 "mulhu %0, %2 # umulsi3_highpart"
 [(set_attr "cost" "18")])

;; Note that mul/mulh take much less clock-cycles
;; when it follow mulh/mul with the same operands value;
;; as it return the result without recomputation.
(define_expand "mulsidi3"
 [(set (match_operand:DI 0 "register_operand" "=r")
        (mult:DI
         (sign_extend:DI (match_operand:SI 1 "register_operand" "0"))
         (sign_extend:DI (match_operand:SI 2 "register_operand" "r"))))]
 ""
 {
   rtx lo = gen_lowpart (SImode, operands[0]);
   rtx hi = gen_highpart (SImode, operands[0]);
   emit_insn (gen_ssmulsi3 (lo, operands[1], operands[2]));
   emit_insn (gen_smulsi3_highpart (hi, operands[1], operands[2]));
   DONE;
 })

;; Note that umul/umulh take much less clock-cycles
;; when it follow umulh/umul with the same operands value;
;; as it return the result without recomputation.
(define_expand "umulsidi3"
 [(set (match_operand:DI 0 "register_operand" "=r")
        (mult:DI
         (zero_extend:DI (match_operand:SI 1 "register_operand" "0"))
         (zero_extend:DI (match_operand:SI 2 "register_operand" "r"))))]
 ""
 {
   rtx lo = gen_lowpart (SImode, operands[0]);
   rtx hi = gen_highpart (SImode, operands[0]);
   emit_insn (gen_mulsi3 (lo, operands[1], operands[2]));
   emit_insn (gen_umulsi3_highpart (hi, operands[1], operands[2]));
   DONE;
 })

(define_insn "divsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (div:SI
        (match_operand:SI 1 "register_operand" "0")
        (match_operand:SI 2 "register_operand" "r")))]
 ""
 "div %0, %2 # divsi3"
 [(set_attr "cost" "34")])

(define_insn "udivsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (udiv:SI
        (match_operand:SI 1 "register_operand" "0")
        (match_operand:SI 2 "register_operand" "r")))]
 ""
 "divu %0, %2 # udivsi3"
 [(set_attr "cost" "34")])

(define_insn "modsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (mod:SI
        (match_operand:SI 1 "register_operand" "0")
        (match_operand:SI 2 "register_operand" "r")))]
 ""
 "mod %0, %2 # modsi3"
 [(set_attr "cost" "34")])

(define_insn "umodsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (umod:SI
        (match_operand:SI 1 "register_operand" "0")
        (match_operand:SI 2 "register_operand" "r")))]
 ""
 "modu %0, %2 # umodsi3"
 [(set_attr "cost" "34")])

;; -------------------------------------------------------------------------
;; Unary arithmetic instructions
;; -------------------------------------------------------------------------

(define_insn "negsi2"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (neg:SI (match_operand:SI 1 "register_operand" "0")))]
 ""
 "not %0, %0; inc8 %0, 1 # negsi2"
 [(set_attr "length" "4")])

(define_insn "one_cmplsi2"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (not:SI (match_operand:SI 1 "register_operand" "0")))]
 ""
 "not %0, %0 # one_cmplsi2")

;; -------------------------------------------------------------------------
;; Bitwise instructions
;; -------------------------------------------------------------------------

(define_insn "andsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (and:SI (match_operand:SI 1 "register_operand" "0")
               (match_operand:SI 2 "register_operand" "r")))]
 ""
 "and %0, %2 # andsi3")

(define_insn "xorsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (xor:SI (match_operand:SI 1 "register_operand" "0")
               (match_operand:SI 2 "register_operand" "r")))]
 ""
 "xor %0, %2 # xorsi3")

(define_insn "iorsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (ior:SI (match_operand:SI 1 "register_operand" "0")
               (match_operand:SI 2 "register_operand" "r")))]
 ""
 "or %0, %2 # iorsi3")

;; -------------------------------------------------------------------------
;; Shift instructions
;; -------------------------------------------------------------------------

(define_insn "ashlsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (ashift:SI (match_operand:SI 1 "register_operand" "0")
                  (match_operand:SI 2 "register_operand" "r")))]
 ""
 "sll %0, %2 # ashlsi3")

(define_insn "ashrsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (ashiftrt:SI (match_operand:SI 1 "register_operand" "0")
                    (match_operand:SI 2 "register_operand" "r")))]
 ""
 "sra %0, %2 # ashrsi3")

(define_insn "lshrsi3"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
                    (match_operand:SI 2 "register_operand" "r")))]
 ""
 "srl %0, %2 # lshrsi3")

;;----------------------------------------------------------------
;; Floating-point instructions
;;----------------------------------------------------------------

(define_insn "addsf3"
 [(set (match_operand:SF 0 "register_operand" "=r")
       (plus:SF (match_operand:SF 1 "register_operand" "0")
                (match_operand:SF 2 "register_operand" "r")))]
 ""
 "fadd %0, %2 # addsf3"
 [(set_attr "cost" "34")])

(define_insn "subsf3"
 [(set (match_operand:SF 0 "register_operand" "=r")
       (minus:SF (match_operand:SF 1 "register_operand" "0")
                 (match_operand:SF 2 "register_operand" "r")))]
 ""
 "fsub %0, %2 # subsf3"
 [(set_attr "cost" "34")])

(define_insn "mulsf3"
 [(set (match_operand:SF 0 "register_operand" "=r")
       (mult:SF (match_operand:SF 1 "register_operand" "0")
                (match_operand:SF 2 "register_operand" "r")))]
 ""
 "fmul %0, %2 # mulsf3"
 [(set_attr "cost" "34")])

(define_insn "divsf3"
 [(set (match_operand:SF 0 "register_operand" "=r")
       (div:SF (match_operand:SF 1 "register_operand" "0")
               (match_operand:SF 2 "register_operand" "r")))]
 ""
 "fdiv %0, %2 # divsf3"
 [(set_attr "cost" "34")])

;; -------------------------------------------------------------------------
;; Move instructions
;; -------------------------------------------------------------------------

(define_insn "movsi_push"
 [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
       (match_operand:SI 0 "register_operand" "r"))]
 ""
 "inc8 %%sp, -4; st32 %0, %%sp # push"
 [(set_attr "length" "4")
  (set_attr "cost" "4")])

(define_insn "movsi_pop"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (mem:SI (post_inc:SI (reg:SI SP_REG))))]
 ""
 {
   if ((REGNO (operands[0]) == PU32_RETURN_POINTER_REGNUM) && TARGET_ZPOPRP)
     return "ld32 %0, %%sp; li8 %%sr, 0; st32 %%sr, %%sp; inc8 %%sp, 4 # zpoprp";
   else
     return "ld32 %0, %%sp; inc8 %%sp, 4 # pop";
 }
 [(set_attr "length" "4")
  (set_attr "cost" "4")])

(define_expand "movsi"
 [(set (match_operand:SI 0 "nonimmediate_operand" "")
       (match_operand:SI 1 "general_operand"      ""))]
 ""
 {
   rtx op0 = operands[0];
   rtx op1 = operands[1];
   if (tls_symbolic_operand (op0, VOIDmode)) {
     rtx arg0 = gen_rtx_REG (SImode, PU32_FIRST_ARG_REGNUM);
     rtx arg1 = gen_rtx_REG (SImode, PU32_FIRST_ARG_REGNUM+1);
     emit_insn (gen__Tmovsi (arg1, op0, arg0));
     rtx fn = gen_rtx_MEM (FUNCTION_MODE, gen_pu32_tga());
     rtx_insn *insn = emit_call_insn (gen_call_value (arg0, fn, const0_rtx));
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg0);
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg1);
     if (GET_CODE (op0) == MEM)
       arg0 = gen_rtx_MEM (SImode, arg0);
     operands[0] = arg0;
   }
   if (tls_symbolic_operand (op1, VOIDmode)) {
     rtx arg0 = gen_rtx_REG (SImode, PU32_FIRST_ARG_REGNUM);
     rtx arg1 = gen_rtx_REG (SImode, PU32_FIRST_ARG_REGNUM+1);
     emit_insn (gen__Tmovsi (arg1, op1, arg0));
     rtx fn = gen_rtx_MEM (FUNCTION_MODE, gen_pu32_tga());
     rtx_insn *insn = emit_call_insn (gen_call_value (arg0, fn, const0_rtx));
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg0);
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg1);
     if (GET_CODE (op1) == MEM)
       emit_insn (gen__movsi (arg0, gen_rtx_MEM (SImode, arg0)));
     operands[1] = arg0;
   }
   emit_insn (gen__movsi (operands[0], operands[1]));
   DONE;
 })

(define_insn "_movsi"
 [(set (match_operand:SI 0 "nonimmediate_operand" "=r,B,r,W,r,r,r,r,r,r")
       (match_operand:SI 1 "general_operand"      " A,r,B,r,W,O,I,J,n,r"))]
 ""
 {
   switch (which_alternative) {
     case 0: return "rli %0, %1 # movsi_r_A";
     case 1:
       if (MEM_VOLATILE_P (operands[0]))
         return "rli %%sr, %0; st32v %1, %%sr # movsi_B_r #volatile";
       else
         return "rli %%sr, %0; st32 %1, %%sr # movsi_B_r";
     case 2:
       if (MEM_VOLATILE_P (operands[1]))
         return "rli %%sr, %1; ld32v %0, %%sr # movsi_r_B #volatile";
       else
         return "rli %%sr, %1; ld32 %0, %%sr # movsi_r_B";
     case 3:
       if (MEM_VOLATILE_P (operands[0]))
         return "st32v %1, %0 # movsi_W_r #volatile";
       else
         return "st32 %1, %0 # movsi_W_r";
     case 4:
       if (MEM_VOLATILE_P (operands[1]))
         return "ld32v %0, %1 # movsi_r_W #volatile";
       else
         return "ld32 %0, %1 # movsi_r_W";
     case 5: return "li8 %0, 0 # movsi_r_O";
     case 6: return "li8 %0, %1 # movsi_r_I";
     case 7: return "li16 %0, %1 # movsi_r_J";
     case 8: return "li32 %0, %1 # movsi_r_n";
     case 9: {
       // Logic used to prevent generating nop,
       // as it must be explicitly generated using
       // the corresponding assembly and never implicitly.
       if (REGNO (operands[0]) == STACK_POINTER_REGNUM &&
           REGNO (operands[1]) == STACK_POINTER_REGNUM)
         return "# cpy %0, %1 # movsi_r_r";
       else
         return "cpy %0, %1 # movsi_r_r";
     }
     default: gcc_unreachable ();
   }
 }
 [(set_attr "length" "2,4,4,2,2,2,2,4,6,2")
  (set_attr "cost" "1,4,4,3,3,1,1,2,3,1")])

(define_insn "_Tmovsi"
 [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
       (match_operand:SI 1 "general_operand"      " T"))
  (clobber
       (match_operand:SI 2 "register_operand"     "=r"))]
 ""
 {
   switch (which_alternative) {
     case 0:
       if (REGNO (operands[0]) == (PU32_FIRST_ARG_REGNUM+1)) {
         if (MEM_VOLATILE_P (operands[1]))
           return ".type %1, @tls_object; li32 %%1, 0; li %%2, %1 # movsi_r_T #volatile";
         else
           return ".type %1, @tls_object; li32 %%1, 0; li %%2, %1 # movsi_r_T";
       }
     default: gcc_unreachable ();
   }
 }
 [(set_attr "length" "8")])

(define_insn "zero_extendqisi2"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (zero_extend:SI (match_operand:QI 1 "register_operand" "0")))]
 ""
 "li16 %%sr, 0xff; and %0, %%sr # zero_extendqisi2"
 [(set_attr "length" "6")])

(define_insn "zero_extendhisi2"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (zero_extend:SI (match_operand:HI 1 "register_operand" "0")))]
 ""
 "li32 %%sr, 0xffff; and %0, %%sr # zero_extendhisi2"
 [(set_attr "length" "8")])

(define_insn "extendqisi2"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (sign_extend:SI (match_operand:QI 1 "register_operand" "0")))]
 ""
 "li8 %%sr, 24; sll %0, %%sr; sra %0, %%sr # extendqisi2"
 [(set_attr "length" "6")])

(define_insn "extendhisi2"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (sign_extend:SI (match_operand:HI 1 "register_operand" "0")))]
 ""
 "li8 %%sr, 16; sll %0, %%sr; sra %0, %%sr # extendhisi2"
 [(set_attr "length" "6")])

(define_expand "movhi"
 [(set (match_operand:HI 0 "nonimmediate_operand" "")
       (match_operand:HI 1 "general_operand"      ""))]
 ""
 {
   rtx op0 = operands[0];
   rtx op1 = operands[1];
   if (tls_symbolic_operand (op0, VOIDmode)) {
     rtx arg0 = gen_rtx_REG (HImode, PU32_FIRST_ARG_REGNUM);
     rtx arg1 = gen_rtx_REG (HImode, PU32_FIRST_ARG_REGNUM+1);
     emit_insn (gen__Tmovhi (arg1, op0, arg0));
     rtx fn = gen_rtx_MEM (FUNCTION_MODE, gen_pu32_tga());
     rtx_insn *insn = emit_call_insn (gen_call_value (arg0, fn, const0_rtx));
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg0);
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg1);
     if (GET_CODE (op0) == MEM)
       arg0 = gen_rtx_MEM (HImode, arg0);
     operands[0] = arg0;
   }
   if (tls_symbolic_operand (op1, VOIDmode)) {
     rtx arg0 = gen_rtx_REG (HImode, PU32_FIRST_ARG_REGNUM);
     rtx arg1 = gen_rtx_REG (HImode, PU32_FIRST_ARG_REGNUM+1);
     emit_insn (gen__Tmovhi (arg1, op1, arg0));
     rtx fn = gen_rtx_MEM (FUNCTION_MODE, gen_pu32_tga());
     rtx_insn *insn = emit_call_insn (gen_call_value (arg0, fn, const0_rtx));
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg0);
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg1);
     if (GET_CODE (op1) == MEM)
       emit_insn (gen__movhi (arg0, gen_rtx_MEM (HImode, arg0)));
     operands[1] = arg0;
   }
   emit_insn (gen__movhi (operands[0], operands[1]));
   DONE;
 })

(define_insn "_movhi"
 [(set (match_operand:HI 0 "nonimmediate_operand" "=r,B,r,W,r,r,r,r,r")
       (match_operand:HI 1 "general_operand"      " A,r,B,r,W,O,I,J,r"))]
 ""
 {
   switch (which_alternative) {
     case 0: return "rli %0, %1 # movhi_r_A";
     case 1:
       if (MEM_VOLATILE_P (operands[0]))
         return "rli %%sr, %0; st16v %1, %%sr # movhi_B_r #volatile";
       else
         return "rli %%sr, %0; st16 %1, %%sr # movhi_B_r";
     case 2:
       if (MEM_VOLATILE_P (operands[1]))
         return "rli %%sr, %1; ld16v %0, %%sr # movhi_r_B #volatile";
       else
         return "rli %%sr, %1; ld16 %0, %%sr # movhi_r_B";
     case 3:
       if (MEM_VOLATILE_P (operands[0]))
         return "st16v %1, %0 # movhi_W_r #volatile";
       else
         return "st16 %1, %0 # movhi_W_r";
     case 4:
       if (MEM_VOLATILE_P (operands[1]))
         return "ld16v %0, %1 # movhi_r_W #volatile";
       else
         return "ld16 %0, %1 # movhi_r_W";
     case 5: return "li8 %0, 0 # movhi_r_O";
     case 6: return "li8 %0, %1 # movhi_r_I";
     case 7: return "li16 %0, %1 # movhi_r_J";
     case 8: {
       // Logic used to prevent generating nop,
       // as it must be explicitly generated using
       // the corresponding assembly and never implicitly.
       if (REGNO (operands[0]) == STACK_POINTER_REGNUM &&
           REGNO (operands[1]) == STACK_POINTER_REGNUM)
         return "# cpy %0, %1 # movhi_r_r";
       else
         return "cpy %0, %1 # movhi_r_r";
     }
     default: gcc_unreachable ();
   }
 }
 [(set_attr "length" "2,4,4,2,2,2,2,4,2")
  (set_attr "cost" "1,4,4,3,3,1,1,2,1")])

(define_insn "_Tmovhi"
 [(set (match_operand:HI 0 "nonimmediate_operand" "=r")
       (match_operand:HI 1 "general_operand"      " T"))
  (clobber
       (match_operand:HI 2 "register_operand"     "=r"))]
 ""
 {
   switch (which_alternative) {
     case 0:
       if (REGNO (operands[0]) == (PU32_FIRST_ARG_REGNUM+1)) {
         if (MEM_VOLATILE_P (operands[1]))
           return ".type %1, @tls_object; li32 %%1, 0; li %%2, %1 # movhi_r_T #volatile";
         else
           return ".type %1, @tls_object; li32 %%1, 0; li %%2, %1 # movhi_r_T";
       }
     default: gcc_unreachable ();
   }
 }
 [(set_attr "length" "8")])

(define_expand "movqi"
 [(set (match_operand:QI 0 "nonimmediate_operand" "")
       (match_operand:QI 1 "general_operand"      ""))]
 ""
 {
   rtx op0 = operands[0];
   rtx op1 = operands[1];
   if (tls_symbolic_operand (op0, VOIDmode)) {
     rtx arg0 = gen_rtx_REG (QImode, PU32_FIRST_ARG_REGNUM);
     rtx arg1 = gen_rtx_REG (QImode, PU32_FIRST_ARG_REGNUM+1);
     emit_insn (gen__Tmovqi (arg1, op0, arg0));
     rtx fn = gen_rtx_MEM (FUNCTION_MODE, gen_pu32_tga());
     rtx_insn *insn = emit_call_insn (gen_call_value (arg0, fn, const0_rtx));
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg0);
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg1);
     if (GET_CODE (op0) == MEM)
       arg0 = gen_rtx_MEM (QImode, arg0);
     operands[0] = arg0;
   }
   if (tls_symbolic_operand (op1, VOIDmode)) {
     rtx arg0 = gen_rtx_REG (QImode, PU32_FIRST_ARG_REGNUM);
     rtx arg1 = gen_rtx_REG (QImode, PU32_FIRST_ARG_REGNUM+1);
     emit_insn (gen__Tmovqi (arg1, op1, arg0));
     rtx fn = gen_rtx_MEM (FUNCTION_MODE, gen_pu32_tga());
     rtx_insn *insn = emit_call_insn (gen_call_value (arg0, fn, const0_rtx));
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg0);
     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg1);
     if (GET_CODE (op1) == MEM)
       emit_insn (gen__movqi (arg0, gen_rtx_MEM (QImode, arg0)));
     operands[1] = arg0;
   }
   emit_insn (gen__movqi (operands[0], operands[1]));
   DONE;
 })

(define_insn "_movqi"
 [(set (match_operand:QI 0 "nonimmediate_operand" "=r,B,r,W,r,r,r,r")
       (match_operand:QI 1 "general_operand"      " A,r,B,r,W,O,I,r"))]
 ""
 {
   switch (which_alternative) {
     case 0: return "rli %0, %1 # movqi_r_A";
     case 1:
       if (MEM_VOLATILE_P (operands[0]))
         return "rli %%sr, %0; st8v %1, %%sr # movqi_B_r #volatile";
       else
         return "rli %%sr, %0; st8 %1, %%sr # movqi_B_r";
     case 2:
       if (MEM_VOLATILE_P (operands[1]))
         return "rli %%sr, %1; ld8v %0, %%sr # movqi_r_B #volatile";
       else
         return "rli %%sr, %1; ld8 %0, %%sr # movqi_r_B";
     case 3:
       if (MEM_VOLATILE_P (operands[0]))
         return "st8v %1, %0 # movqi_W_r #volatile";
       else
         return "st8 %1, %0 # movqi_W_r";
     case 4:
       if (MEM_VOLATILE_P (operands[1]))
         return "ld8v %0, %1 # movqi_r_W #volatile";
       else
         return "ld8 %0, %1 # movqi_r_W";
     case 5: return "li8 %0, 0 # movqi_r_O";
     case 6: return "li8 %0, %1 # movqi_r_I";
     case 7: {
       // Logic used to prevent generating nop,
       // as it must be explicitly generated using
       // the corresponding assembly and never implicitly.
       if (REGNO (operands[0]) == STACK_POINTER_REGNUM &&
           REGNO (operands[1]) == STACK_POINTER_REGNUM)
         return "# cpy %0, %1 # movqi_r_r";
       else
         return "cpy %0, %1 # movqi_r_r";
     }
     default: gcc_unreachable ();
   }
 }
 [(set_attr "length" "2,4,4,2,2,2,2,2")
  (set_attr "cost" "1,4,4,3,3,1,1,1")])

(define_insn "_Tmovqi"
 [(set (match_operand:QI 0 "nonimmediate_operand" "=r")
       (match_operand:QI 1 "general_operand"      " T"))
  (clobber
       (match_operand:QI 2 "register_operand"     "=r"))]
 ""
 {
   switch (which_alternative) {
     case 0:
       if (REGNO (operands[0]) == (PU32_FIRST_ARG_REGNUM+1)) {
         if (MEM_VOLATILE_P (operands[1]))
           return ".type %1, @tls_object; li32 %%1, 0; li %%2, %1 # movqi_r_T #volatile";
         else
           return ".type %1, @tls_object; li32 %%1, 0; li %%2, %1 # movqi_r_T";
       }
     default: gcc_unreachable ();
   }
 }
 [(set_attr "length" "8")])

;; -------------------------------------------------------------------------
;; Atomic instructions
;; -------------------------------------------------------------------------

(define_mode_iterator LDSTMODE [QI HI SI])
(define_mode_attr LDSTMODESZ [(QI "8") (HI "16") (SI "32")])

(define_insn "atomic_exchange<mode>"
 [(set (match_operand:LDSTMODE 0 "register_operand" "=r,r")
       (match_operand:LDSTMODE 1 "memory_operand" "+B,W"))
  (set (match_dup 1)
       (unspec:LDSTMODE
        [(match_operand:LDSTMODE 2 "register_operand" "0,0")
         (match_operand:LDSTMODE 3 "const_int_operand")]
        0))]
 ""
 {
   switch (which_alternative) {
     case 0:
       if (MEM_VOLATILE_P (operands[1]))
         return "rli %%sr, %1; ldst<LDSTMODESZ> %0, %%sr # atomic_exchange<mode>_r_B #volatile";
       else
         return "rli %%sr, %1; ldst<LDSTMODESZ> %0, %%sr # atomic_exchange<mode>_r_B";
     case 1:
       if (MEM_VOLATILE_P (operands[1]))
         return "ldst<LDSTMODESZ> %0, %1 # atomic_exchange<mode>_r_W #volatile";
       else
         return "ldst<LDSTMODESZ> %0, %1 # atomic_exchange<mode>_r_W";
     default: gcc_unreachable ();
   }
 }
 [(set_attr "length" "4,2")
  (set_attr "cost" "6,5")])

;; -------------------------------------------------------------------------
;; Compare instructions
;; -------------------------------------------------------------------------

(define_expand "cstoresi4"
 [(set (match_operand:SI 0 "register_operand")
       (match_operator:SI 1 "ordered_comparison_operator"
        [(match_operand:SI 2 "general_operand")
         (match_operand:SI 3 "general_operand")]))]
 ""
 {
   if (GET_CODE (operands[2]) != REG)
     operands[2] = force_reg (SImode, operands[2]);
   if (GET_CODE (operands[3]) != REG)
     operands[3] = force_reg (SImode, operands[3]);
 })

(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
(define_code_attr COND [(ne "ne") (eq "eq") (lt "lt") (ltu "ltu")
                        (gt "gt") (gtu "gtu") (ge "gte") (le "lte")
                        (geu "gteu") (leu "lteu")])

(define_insn "*cstoresi4"
 [(set (match_operand:SI 0 "register_operand" "=r")
       (cond:SI (match_operand:SI 1 "register_operand" "0")
                (match_operand:SI 2 "register_operand" "r")))]
 ""
 "s<COND> %0, %2 # cstoresi4_<COND>")

;; -------------------------------------------------------------------------
;; Conditional branch instructions
;; -------------------------------------------------------------------------

(define_insn "jumpiftrue"
 [(set (pc)
       (if_then_else (ne
                      (match_operand:SI 0 "register_operand" "r")
                      (const_int 0))
                     (label_ref (match_operand 1 "" ""))
                     (pc)))]
 ""
 "rli %%sr, %l1; jnz %0, %%sr # jumpiftrue"
 [(set_attr "length" "4")])

(define_insn "jumpiffalse"
 [(set (pc)
       (if_then_else (eq
                      (match_operand:SI 0 "register_operand" "r")
                      (const_int 0))
                     (label_ref (match_operand 1 "" ""))
                     (pc)))]
 ""
 "rli %%sr, %l1; jz %0, %%sr # jumpiffalse"
 [(set_attr "length" "4")])

(define_expand "cbranchsi4"
 [(set (pc)
       (if_then_else (match_operator 0 "ordered_comparison_operator"
                      [(match_operand:SI 1 "general_operand")
                       (match_operand:SI 2 "general_operand")])
                     (label_ref (match_operand 3 "" ""))
                     (pc)))]
 ""
 {
   rtx tmp = gen_reg_rtx (SImode);
   emit_insn (gen_cstoresi4 (tmp, operands[0], operands[1], operands[2]));
   emit_jump_insn (gen_jumpiftrue (tmp, operands[3]));
   DONE;
 })

;; -------------------------------------------------------------------------
;; Branch instructions
;; -------------------------------------------------------------------------

(define_insn "indirect_jump"
 [(set (pc) (match_operand 0 "nonimmediate_operand" "r"))]
 ""
 "j %0 # indirect_jump")

;; Note that the mnemonic "j" can only branch
;; to a non-null address as it translates to "jnz".
(define_insn "jump"
 [(set (pc) (label_ref (match_operand 0 "" "")))]
 ""
 "rli %%sr, %l0; j %%sr # jump"
 [(set_attr "length" "4")])

;; -------------------------------------------------------------------------
;; Call instructions
;; -------------------------------------------------------------------------

(define_insn "call"
 [(call (match_operand 0 "memory_operand" "B,Wr")
        (match_operand 1 "" ""))
  (clobber (reg:SI RP_REG))]
 ""
 "@
  rli %%sr, %0; jl %%rp, %%sr; # call_B
  jl %%rp, %0; # call_Wr"
 [(set_attr "length" "4,2")])

(define_insn "call_value"
 [(set (match_operand 0 "register_operand" "=r,r")
       (call (match_operand 1 "memory_operand" "B,Wr")
             (match_operand 2 "" "")))
  (clobber (reg:SI RP_REG))]
 ""
 "@
  rli %%sr, %1; jl %%rp, %%sr; # call_value_B
  jl %%rp, %1; # call_value_Wr"
 [(set_attr "length" "4,2")])

;; -------------------------------------------------------------------------
;; Prologue & Epilogue
;; -------------------------------------------------------------------------

(define_expand "prologue"
 [(clobber (const_int 0))]
 ""
 {
   pu32_expand_prologue ();
   DONE;
 })

(define_expand "epilogue"
 [(return)]
 ""
 {
   pu32_expand_epilogue ();
   DONE;
 })

(define_insn "retlr"
 [(return)
  (use (reg:SI RP_REG))]
 "reload_completed"
 {
   return pu32_output_return();
 })

(define_insn "blockage"
 [(unspec_volatile [(const_int 0)] 0)]
 ""
 "# blockage"
 [(set_attr "length"   "0")])
